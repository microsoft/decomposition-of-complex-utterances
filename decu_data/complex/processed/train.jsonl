{"steps": [{"step_index": 0, "step": "Check if there are no emails about shiproom"}, {"step_index": 1, "step": "If s1 is true, set up a 1:1 with Smith titled \"Discussion about Shiproom\""}], "utterance": "If I don't have an email about shiproom, then set up a 1:1 with Smith titled Discussion about Shiproom", "plans": ["val s1 = findEmails(messageTitleIs(\"shiproom\")).isEmpty", "val s2 = Option.when(s1){createEvent(isOneOnOne and with_(\"Smith\") and called(\"Discussion about Shiproom\"))}"], "datum_id": "d1", "utterance_id": "d1", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find all one on one events from last week and return the size of that list"}], "utterance": "How many 1/1 meetings in total I had in the last week?", "plans": ["val s1 = findEvents(queryAt(last[Interval[Date]] and isWeek) and isOneOnOne).size"], "datum_id": "d304", "utterance_id": "d304", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find event called \"pizza party\""}, {"step_index": 1, "step": "Find events starting between 1 pm and 2:30 pm that are not titled \"pizza party\""}, {"step_index": 2, "step": "If the list s2 is empty then update the event s1 to end at 2:30 pm."}], "utterance": "Extend pizza party at 1 PM to end at 2.30 pm if extending it doesn't overlap with the next event.", "plans": ["val s1 = theEvent(called(\"pizza party\") and queryAt((1).pm))", "val s2 = findEvents(not(called(\"pizza party\")) and queryAt(timeInterval(1.pm, (2::30).pm)))", "val s3 = Option.when(s2.isEmpty){modifyEvent(s1, endsAt((2 :: 30).pm))}"], "datum_id": "d395", "utterance_id": "d395", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find the event called Standup"}, {"step_index": 1, "step": "Get the attendees of the event s1"}, {"step_index": 2, "step": "Forward this email to the list of persons s2"}], "utterance": "Forward this email to all the attendees in the Standup event", "plans": ["val s1 = theEvent(called(\"Standup\"))", "val s2 = s1.attendees.all", "val s3 = forwardEmail(messageIdIs(theEmail(`this`[Email]).id) and messageWithTo(s2))"], "datum_id": "d483", "utterance_id": "d483", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find the event called \"doctor's appointment\""}, {"step_index": 1, "step": "Find all events happening next week"}, {"step_index": 2, "step": "Filter the list of events s2 to include only the events that are not the event s1"}, {"step_index": 3, "step": "Filter the list of events s3 to include only the events organized by me and which intersect with the event s1"}, {"step_index": 4, "step": "Update each event in the list s3 to happen after the event s1"}], "utterance": "Find all the meetings scheduled for next week that I created but that conflict with my doctor's appointment. Reschedule them to after the doctor's appointment.", "plans": ["val s1 = theEvent(called(\"doctor's appointment\"))", "val s2 = findEvents(queryAt(next[Interval[Date]] and isWeek))", "val s3 = s2.filter(x => x.id != s1.id)", "val s4 = s3.filter(x => x.organizerIs(me) && x.interval.intersects(s1.interval))", "val s5 = s4.map(x => modifyEvent(x, startsAt(after(s1.interval))))"], "datum_id": "d491", "utterance_id": "d491", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find the event called \"team meeting\" on Wednesday."}, {"step_index": 1, "step": "Find out what time zone Jack is in."}, {"step_index": 2, "step": "Update the event s1 to happen after 8am and before 5pm in the time zone s2."}], "utterance": "Update the team meeting on Wednesday, so that its after 8 AM and before 5 PM for Jack", "plans": ["val s1 = theEvent(called(\"team meeting\") and queryAt(Wednesday))", "val s2 = thePerson(named(\"Jack\")).timeZone", "val s3 = modifyEvent(s1, startsAt(after(8.am) inZone s2) and endsAt(before(5.pm) inZone s2))"], "datum_id": "d505", "utterance_id": "d505", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find the event called \"emergency review\""}, {"step_index": 1, "step": "Subtract 30 minutes from the start time of the event s1"}, {"step_index": 2, "step": "Add 30 minutes to the end time of the event s1"}, {"step_index": 3, "step": "Establish the time interval between the time instant s2 and the time instant s3"}, {"step_index": 4, "step": "Find events that are scheduled for this week"}, {"step_index": 5, "step": "Filter the list of events s5 to keep only those events that intersect with the interval s4"}, {"step_index": 6, "step": "Update each event in the list s6 to happen on the next Friday"}], "utterance": "If there is an \"emergency review\" meeting this week, then reschedule any events that happen 30 minutes before or after the meeting to next Friday.", "plans": ["val s1 = theEvent(called(\"emergency review\"))", "val s2 = s1.start - 30.minutes", "val s3 = s1.end + 30.minutes", "val s4 = Interval[Instant](s2, s3)", "val s5 = findEvents(createAt(`this`[Interval[Date]] and isWeek))", "val s6 = s5.filter(x => x.interval.intersects(s4))", "val s7 = s6.map(x => modifyEvent(x, createAt(next[Date] /& Friday)))"], "datum_id": "d516", "utterance_id": "d516", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find events from last week between 12 PM and 1 PM"}, {"step_index": 1, "step": "Describe the number of events in the list s1"}], "utterance": "Calculate how many meetings last week I had during my lunch hours of 12 noon to 1 PM", "plans": ["val s1 = findEvents(queryAt(timeInterval(12.pm, 1.pm) on (last[Interval[Date]] and isWeek)))", "val s2 = s1.size"], "datum_id": "d525", "utterance_id": "d525", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find the event called \"project sync\""}, {"step_index": 1, "step": "Find my reports"}, {"step_index": 2, "step": "Find my manager's reports"}, {"step_index": 3, "step": "Filter the list of persons s2 to include only people attending the event s1"}, {"step_index": 4, "step": "Filter the list of persons s3 to include only the people attending the event s1"}, {"step_index": 5, "step": "Create an event called preparation meeting this week with the list of persons s4 and the list of persons s5"}], "utterance": "Create a preparation meeting this week with the attendees of the project sync who report to me or my manager.", "plans": ["val s1 = theEvent(called(\"project sync\"))", "val s2 = thePerson(me).directReports", "val s3 = thePerson(me).manager.directReports", "val s4 = s2.filter(x => s1.attendees.isAttending(x))", "val s5 = s3.filter(x => s1.attendees.isAttending(x))", "val s6 = createEvent(with_(s4) and with_(s5) and createAt(thisWeek) and called(\"preparation meeting\"))"], "datum_id": "d545", "utterance_id": "d545", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
{"steps": [{"step_index": 0, "step": "Find the event called project sync tomorrow"}, {"step_index": 1, "step": "Describe the number of attendees of the event s1 excluding the manager"}], "utterance": "Other than my manager, how many people are attending the project sync meeting tomorrow?", "plans": ["val s1 = theEvent(called(\"project sync\") and queryAt(tomorrow))", "val s2 = s1.attendees.all.size - 1"], "datum_id": "d55", "utterance_id": "d55", "reference_steps": null, "reference_datum_id": null, "tags": null, "reference_plans": null, "is_unannotated": false}
